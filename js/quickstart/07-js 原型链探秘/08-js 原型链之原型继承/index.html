<!doctype html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport"
        content="width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">
  <title>js原型链之原型继承</title>
</head>
<body>
  <ul>
    <li>继承是原型的继承，而非改变构造函数的原型(导致其他继承自父类的对象也拥有该原型上的方法)</li>
    <li>通过修改构造函数原型(本质是对象)的原型(__proto__)或通过Object.create()可实现继承</li>
    <li>通过Object.create()实现继承的顺序至关重要，必须保证定义原型方法或新建对象在Object.create()之后进行</li>
    <li>构造函数被回填之后，但正常来说不需要被遍历，可使用Object.defineProperty修改enumerable属性</li>
    <li>在父类带参构造函数中初始化属性，子类带参构造函数中使用call或apply完成属性初始化</li>
    <li>可利用原型工厂或对象工厂来实现继承, 使用mixin来实现多继承"功能"类(以对象形式存在)</li>
    <li>mixin"功能"类之间也可使用__proto__继承，在"子功能"类中使用this.__proto__或super访问"父功能"类的成员</li>
  </ul>
  <!--改变构造函数的原型不能实现继承-->
  <!--<script src="constructor.js"></script>-->
  <!--继承是原型的继承-->
  <!--<script src="prototype.js"></script>-->
  <!--参数化的构造函数继承-->
  <script src="params.js"></script>
</body>
</html>