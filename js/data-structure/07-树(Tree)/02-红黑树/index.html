<!doctype html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport"
        content="width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">
  <title>红黑树</title>
  <link href="./favicon.ico" rel="shortcut icon">
</head>
<body>
  <ul>
    <li>红黑树：必须是二叉搜索树，满足：</li>
    <li>1).节点是红色或黑色</li>
    <li>2).根节点是黑色</li>
    <li>3).所有叶子节点(NIL节点)都是黑色</li>
    <li>4).如果一个节点是红色，则左右子树直接子节点是黑色(从每个叶子到根的所有路径不能包含连续的红色节点)</li>
    <li>5).从任一节点到达叶子节点的所有路径包含相同数目的黑色节点</li>
    <li>变色：为了维持红黑树的5大规则，插入新节点(红色)或删除已有节点后需将红色变为黑色或黑色变为红色</li>
    <li>左旋转(LR): 将当前要旋转的节点S进行逆时针转90度,然后把要旋转的节点E(未旋转之前)的右节点S的左子树节点挂到要旋转的节点E(已经旋转完毕)的右子树节点</li>
    <li>右旋转(RR): 将当前要旋转的节点E进行顺时针转90度,然后把要旋转的S节点(未旋转之前)的左节点E的右子树节点挂到要旋转的节点S(已经旋转完毕)的左子树节点</li>
    <li>规定：插入新节点(红色)N-Node，父页点P-Parent，祖父节点G-Grandpa，叔叔节点(父节点的兄弟节点)U-Uncle</li>
    <li>场景1：新节点N是根节点，没有父节点P，只需要将红色变为黑色即可</li>
    <li>场景2：新节点N的父节点P是黑色，插入后仍然符合规则，直接插入即可</li>
    <li>场景3：新节点N的父节点P和叔叔节点U都是红色，插入后出现"红红相连"，不符合规则4，应将“父红叔红祖黑(a)”变成"父黑叔黑祖红(b)"</li>
    <li>场景4：新节点N的父节点P是红色，叔叔节点U是黑色，且新节点N是左子树的节点，不符合规则4，将"父红叔黑祖黑(a)"变成"父黑叔黑祖红(c)"，再执行右旋转(b)</li>
    <li>场景5：新节点N的父节点P是红色，叔叔节点U是黑色，且新节点N是右子树的节点，不符合规则4，将以“P”为轴左旋转(a)变成(b)，此时将P和B看成整体(可当作新节点)，此时跟场景4一样，先将新节点N变为黑色，G变为红色，再以G为轴执行右旋转变成(c)</li>
  </ul>
</body>
</html>