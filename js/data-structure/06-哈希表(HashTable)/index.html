<!doctype html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport"
        content="width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">
  <title>哈希表</title>
  <link href="./favicon.ico" rel="shortcut icon">
</head>
<body>
  <ul>
    <li>与数组和链表相比，哈希表基于数组实现并用于存储海量数据，兼具数据快速查找(按下标)和插入删除(接近O(1)的时间复杂度)的优势，甚至比树查找还要快但复杂度比树简单得多</li>
    <li>与集合字典相比，哈希表中的数据也是无序的(导致遍历其中元素比较困难)，其中key也是不可重复的用于保存不同的对象</li>
    <li>虽然基于数组实现，但哈希表通过一种将字符变换为下标(HashCode)机制实现海量数据存储，这种机制称为哈希函数</li>
    <li>Unicode码相加：cats=3+1+20+19=43, 也即转换后的下标为43，但非常容易出现重复(was也是43)，生成的下标偏小</li>
    <li>幂的连乘：cats=3*10^3+1*10^2+20*10+19=3419，这样尽量避免下标重复，但如果有个字符串zzzzzzzz将出现超大的下标值(内存溢出)，生成的下标偏大</li>
    <li>哈希化：基于以上两种方案，不是下标偏小就是偏大，但方案一无法避免重复直接排除，可以通过压缩化方案二(幂的连乘)，即将巨大的整数范围(large)压缩到可接受的数组范围之内(small)，这样可通过取模运算获取下标：index = large % small，但仍然存在重复，即同一个下标可能被多个字符串共存，即存在冲突，希望每一个字符串都能占据一个独立的下标指向的空间，可通过链地址法和开放地址法解决</li>
    <li>链地址法：也成为拉链法，即在产生冲突的下标位上存储一个数组或链表，来保存同一下标位的对象</li>
    <li>开放地址法：通过步长来寻找当前下标位的下一空白下标位来填充冲突的对象，可通过线性探测、二次探测和再哈希法来查找</li>
    <li>哈希表执行插入和搜索的效率非常高，如果没有冲突效率将更高，如果存在冲突，效率将依赖于探测的长度，而探测长度又依赖于填充因子(填充因子=实际哈希表长度/哈希表容量)</li>
    <li>哈希函数：提高计算速度(尽量避免乘法和除法，使用霍纳法则)以便快速获得HashCode，无论是链地址法还是开放地址法，多个元素映射到同一下标都会影响效率，因此应尽量让元素映射到不同位置以便均匀分布(使用质数作为容量)</li>
  </ul>
</body>
</html>